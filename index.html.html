<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Warm Wishes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
    <style>
        body { margin: 0; background: #020103; overflow: hidden; touch-action: none; font-family: 'Apple SD Gothic Neo', 'Malgun Gothic', sans-serif; }
        
        #greeting-overlay {
            position: fixed; inset: 0;
            display: flex; align-items: center; justify-content: center;
            pointer-events: none; z-index: 110;
            opacity: 0; transition: opacity 1s ease-in-out;
            background: rgba(0,0,0,0.4); 
        }
        #greeting-text {
            color: #FF69B4; 
            font-size: 3.5rem; font-weight: bold; text-align: center;
            text-shadow: 0 0 30px rgba(255, 105, 180, 1), 0 0 60px rgba(255, 192, 203, 0.8);
            font-family: serif; letter-spacing: 5px;
            transform: scale(0.8); transition: transform 1s ease-out;
        }

        #message-overlay {
            position: fixed; inset: 0; 
            display: flex; align-items: center; justify-content: center;
            pointer-events: none;
            opacity: 0; transition: opacity 0.8s ease-in-out;
            z-index: 100;
            background: radial-gradient(circle, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.8) 100%);
            cursor: pointer;
        }
        #message-text {
            color: #FFF1C2; font-size: 2.2rem; font-weight: 400; text-align: center;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 160, 50, 0.4);
            letter-spacing: 0.05em; line-height: 1.6;
            padding: 20px;
            white-space: pre-wrap; 
            transform: scale(0.9); transition: transform 0.8s ease;
        }
        
        #hint {
            position: fixed; bottom: 20px; width: 100%; text-align: center;
            color: rgba(255, 182, 193, 0.8); font-size: 1rem; pointer-events: none;
            animation: pulse 2s infinite; z-index: 50; transition: opacity 0.5s;
        }

        /* ★★★ 新增：底部专属名字样式 ★★★ */
        #footer-text {
            position: fixed;
            bottom: 50px; /* 位于提示文字上方一点 */
            width: 100%;
            text-align: center;
            /* 淡雅的暖金色 */
            color: rgba(255, 245, 230, 0.85); 
            /* 优雅的衬线字体搭配斜体，营造花体感 */
            font-family: Georgia, 'Times New Roman', serif;
            font-style: italic; 
            font-size: 0.95rem; /* 小小的 */
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 45; 
            opacity: 0; /* 初始隐藏 */
            transition: opacity 1s ease-in-out;
            text-shadow: 0 0 3px rgba(255, 215, 0, 0.3); /* 微微发光 */
        }

        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
    </style>
</head>
<body>

    <div id="greeting-overlay">
        <div id="greeting-text">Merry Christmas</div>
    </div>

    <div id="message-overlay">
        <div id="message-text"></div>
        <div style="position: absolute; bottom: 100px; font-size: 0.8rem; color: rgba(255,255,255,0.4); letter-spacing: 2px;">
            - 点击屏幕返回 -
        </div>
    </div>
    
    <div id="hint">点击屏幕开启祝福</div>
    
    <div id="footer-text">for 박성찬</div>

    <script type="module">
        const bgm = new Audio('lv_0_20251224152309.mp3'); 
        bgm.loop = true; 
        bgm.volume = 0.5; 

        const messages = [
            "오늘도 수고했어",
            "항상 널 응원할게",
            "아프지 말고 건강해",
            "감기 조심하고 따뜻하게 입어",
            "넌 아주 잘하고 있어",
            "메리 크리스마스!"
        ];
        
        const STATE_INIT = 0;       
        const STATE_GREETING = 1;   
        const STATE_TREE = 2;       
        let currentState = STATE_INIT;
        let isShowingMessage = false; 

        let scene, camera, renderer, raycaster, mouse;
        let treeParticles, treeGeo, treeStarGroup;
        let ribbonParticles, ribbonGeo; 
        let bubbles = []; 
        
        const crystalColors = [
            0xFFB7B2, 0xFFDAC1, 0xE2F0CB, 
            0xB5EAD7, 0xC7CEEA, 0xFFF5BA
        ];
        
        const PARTICLE_COUNT = 25000;
        const treeTargets = new Float32Array(PARTICLE_COUNT * 3);
        const explodeTargets = new Float32Array(PARTICLE_COUNT * 3);

        const RIBBON_COUNT = 5000;
        const ribbonTargets = new Float32Array(RIBBON_COUNT * 3);
        const ribbonExplodeTargets = new Float32Array(RIBBON_COUNT * 3);

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
            grad.addColorStop(0.3, 'rgba(255, 220, 150, 0.8)');
            grad.addColorStop(0.8, 'rgba(255, 180, 60, 0.1)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050201, 0.015);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 40); 
            camera.lookAt(0, 11, 0); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; 
            document.body.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            const ambientLight = new THREE.AmbientLight(0x886644, 1.5); 
            scene.add(ambientLight);
            const mainLight = new THREE.PointLight(0xffd700, 3.0, 100); 
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            scene.add(mainLight);
            const rimLight = new THREE.DirectionalLight(0xff99aa, 2.5); 
            rimLight.position.set(0, 10, -10);
            scene.add(rimLight);
            const bottomLight = new THREE.DirectionalLight(0xffffff, 1.5);
            bottomLight.position.set(0, -20, 5);
            scene.add(bottomLight);

            createTree(); 
            createRibbons(); 
            createBrightBubbles(); 
            createParticleStar(); 

            bubbles.forEach(b => b.visible = false);
            treeStarGroup.scale.set(0, 0, 0); 
            
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', onMainClick);
            const overlay = document.getElementById('message-overlay');
            overlay.addEventListener('click', hideMessage);
        }

        function onMainClick(event) {
            event.preventDefault();
            
            if (currentState === STATE_INIT) {
                bgm.play().catch(error => {
                    console.log("音乐播放失败，请检查文件名是否正确", error);
                });
                showBigGreeting();
                return;
            }
            
            if (currentState === STATE_GREETING) return;
            if (currentState === STATE_TREE && !isShowingMessage) {
                checkBubbleClick(event);
            }
        }

        function showBigGreeting() {
            currentState = STATE_GREETING;
            const greetingOverlay = document.getElementById('greeting-overlay');
            const greetingText = document.getElementById('greeting-text');
            const hint = document.getElementById('hint');
            hint.style.opacity = 0; 
            greetingOverlay.style.opacity = 1;
            greetingText.style.transform = 'scale(1)';
            setTimeout(transitionToTree, 3000);
        }

        function transitionToTree() {
            const greetingOverlay = document.getElementById('greeting-overlay');
            const greetingText = document.getElementById('greeting-text');
            greetingOverlay.style.opacity = 0;
            greetingText.style.transform = 'scale(0.8)';

            bubbles.forEach(b => b.visible = true);
            
            const hint = document.getElementById('hint');
            hint.innerText = "点击通透的水晶球接收祝福";
            hint.style.opacity = 1;
            
            // ★★★ 树出现时，显示底部的名字 ★★★
            document.getElementById('footer-text').style.opacity = 1;

            currentState = STATE_TREE;
        }

        function createParticleStar() {
            treeStarGroup = new THREE.Group();
            treeStarGroup.position.set(0, 21.0, 0);

            const starGeo = new THREE.BufferGeometry();
            const starPositions = [];
            const starColors = [];
            
            const particleCount = 850; 
            const outerRadius = 1.2; 
            const innerRadius = 0.45; 
            const thickness = 0.3; 

            const cGoldDeep = new THREE.Color(0xFFC300); 
            const cGoldLight = new THREE.Color(0xFFE580); 

            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                let valid = false;
                let attempts = 0;

                while (!valid && attempts < 20) {
                    x = (Math.random() - 0.5) * 2 * outerRadius;
                    y = (Math.random() - 0.5) * 2 * outerRadius;
                    const angle = Math.atan2(y, x) + Math.PI / 2; 
                    const r = Math.sqrt(x*x + y*y);
                    const sectorAngle = (2 * Math.PI) / 5;
                    let localAngle = angle % sectorAngle;
                    if (localAngle < 0) localAngle += sectorAngle;
                    localAngle = Math.abs(localAngle - sectorAngle / 2); 
                    const t = localAngle / (sectorAngle / 2); 
                    const maxR = outerRadius * (1 - t) + innerRadius * t * 1.2; 

                    if (r <= maxR) {
                        valid = true;
                        const depthFade = 1 - (r / outerRadius);
                        z = (Math.random() - 0.5) * thickness * (0.5 + 0.5 * depthFade);
                    }
                    attempts++;
                }
                
                if(valid) {
                    starPositions.push(x, y, z);
                    const rand = Math.random();
                    let color = cGoldDeep.clone().lerp(cGoldLight, rand);
                    starColors.push(color.r, color.g, color.b);
                }
            }

            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));

            const starMat = new THREE.PointsMaterial({
                size: 0.22, 
                map: createGlowTexture(),
                vertexColors: true,
                transparent: true,
                opacity: 0.95,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const starPoints = new THREE.Points(starGeo, starMat);
            treeStarGroup.add(starPoints);

            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: createGlowTexture(), 
                color: 0xFFC300, 
                transparent: true, 
                opacity: 0.4, 
                blending: THREE.AdditiveBlending 
            });
            const glowSprite = new THREE.Sprite(spriteMaterial);
            glowSprite.scale.set(5.0, 5.0, 1.0); 
            treeStarGroup.add(glowSprite);

            const starLight = new THREE.PointLight(0xFFC300, 1.5, 15); 
            starLight.position.z = 0.5;
            treeStarGroup.add(starLight);

            scene.add(treeStarGroup);
        }

        function createTree() {
            treeGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = [];
            
            const c1 = new THREE.Color('#FFC0CB'); 
            const c2 = new THREE.Color('#FF69B4'); 
            const c3 = new THREE.Color('#FFF0F5'); 

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const h = Math.random() * 22; 
                const rBase = (1 - h / 23) * 7 + Math.random() * 0.5;
                const angle = h * 5 + Math.random() * Math.PI * 2; 
                treeTargets[i*3] = Math.cos(angle) * rBase;
                treeTargets[i*3+1] = h - 2; 
                treeTargets[i*3+2] = Math.sin(angle) * rBase;
                
                const radius = 25 + Math.random() * 35; 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                explodeTargets[i*3] = radius * Math.sin(phi) * Math.cos(theta);
                explodeTargets[i*3+1] = radius * Math.sin(phi) * Math.sin(theta) + 10; 
                explodeTargets[i*3+2] = radius * Math.cos(phi);
                
                positions[i*3] = explodeTargets[i*3];
                positions[i*3+1] = explodeTargets[i*3+1];
                positions[i*3+2] = explodeTargets[i*3+2];

                const rand = Math.random();
                let color;
                if (rand > 0.8) color = c3; 
                else color = c1.clone().lerp(c2, Math.random());
                colors.push(color.r, color.g, color.b);
            }

            treeGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            treeGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({
                size: 0.28, map: createGlowTexture(), vertexColors: true,
                transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false
            });
            treeParticles = new THREE.Points(treeGeo, mat);
            scene.add(treeParticles);
        }

        function createRibbons() {
            ribbonGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(RIBBON_COUNT * 3);
            const colors = [];
            const white = new THREE.Color('#FFFFFF'); 
            for (let i = 0; i < RIBBON_COUNT; i++) {
                const h = (i / RIBBON_COUNT) * 22; 
                const rBase = (1 - h / 23.5) * 8; 
                const angle = h * 4 + Math.PI * 2; 
                ribbonTargets[i*3] = Math.cos(angle) * rBase;
                ribbonTargets[i*3+1] = h - 2; 
                ribbonTargets[i*3+2] = Math.sin(angle) * rBase;
                
                const radius = 25 + Math.random() * 35;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                ribbonExplodeTargets[i*3] = radius * Math.sin(phi) * Math.cos(theta);
                ribbonExplodeTargets[i*3+1] = radius * Math.sin(phi) * Math.sin(theta) + 10;
                ribbonExplodeTargets[i*3+2] = radius * Math.cos(phi);
                
                positions[i*3] = ribbonExplodeTargets[i*3];
                positions[i*3+1] = ribbonExplodeTargets[i*3+1];
                positions[i*3+2] = ribbonExplodeTargets[i*3+2];

                colors.push(white.r, white.g, white.b);
            }
            ribbonGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            ribbonGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({
                size: 0.25, map: createGlowTexture(), vertexColors: true,
                transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false
            });
            ribbonParticles = new THREE.Points(ribbonGeo, mat);
            scene.add(ribbonParticles);
        }

        function createBrightBubbles() {
            const sphereGeo = new THREE.SphereGeometry(1.0, 64, 64); 

            for (let i = 0; i < 6; i++) {
                const bubbleGroup = new THREE.Group();
                const colorHex = crystalColors[i % crystalColors.length];
                
                const mat = new THREE.MeshPhysicalMaterial({
                    color: colorHex, 
                    metalness: 0.1, roughness: 0.1, transmission: 0.6, thickness: 1.0, 
                    clearcoat: 1.0, clearcoatRoughness: 0.0, transparent: true, opacity: 0.9,
                    emissive: colorHex, emissiveIntensity: 0.6, toneMapped: false
                });

                const bubble = new THREE.Mesh(sphereGeo, mat);
                bubbleGroup.add(bubble);
                const angle = (i / 6) * Math.PI * 2 + Math.random();
                const h = 5 + Math.random() * 12; 
                const r = 8 + Math.random() * 6; 
                bubbleGroup.position.set(Math.cos(angle) * r, h, Math.sin(angle) * r);
                bubbleGroup.userData.initialPos = bubbleGroup.position.clone();
                bubbleGroup.userData.offset = new THREE.Vector3(Math.random(), Math.random(), Math.random());
                bubbleGroup.userData.speed = 0.0003 + Math.random() * 0.0004;
                bubbleGroup.userData.isBubbleGroup = true;
                bubbleGroup.userData.messageIndex = i;
                bubbles.push(bubbleGroup);
                scene.add(bubbleGroup);
            }
        }

        function checkBubbleClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbles, true); 
            if (intersects.length > 0) {
                let target = intersects[0].object;
                while (target.parent && !target.userData.isBubbleGroup) target = target.parent;
                if (target.userData.isBubbleGroup && target.userData.messageIndex !== undefined) showMessage(target.userData.messageIndex);
            }
        }

        function showMessage(index) {
            isShowingMessage = true;
            const msg = messages[index];
            const textEl = document.getElementById('message-text');
            textEl.innerText = msg;
            textEl.style.transform = 'scale(1)';
            const overlay = document.getElementById('message-overlay');
            overlay.style.opacity = '1';
            overlay.style.pointerEvents = 'auto';
            document.getElementById('hint').style.opacity = '0';
            // ★★★ 查看祝福时，暂时隐藏底部的名字，聚焦信息 ★★★
            document.getElementById('footer-text').style.opacity = 0;
        }

        function hideMessage() {
            isShowingMessage = false;
            const overlay = document.getElementById('message-overlay');
            overlay.style.opacity = '0';
            overlay.style.pointerEvents = 'none';
            document.getElementById('message-text').style.transform = 'scale(0.9)';
            document.getElementById('hint').style.opacity = '1';
            // ★★★ 关闭祝福时，恢复显示底部的名字 ★★★
            document.getElementById('footer-text').style.opacity = 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            let targetTree, targetRibbon;
            let starTargetScale = 0;

            if (currentState === STATE_INIT || currentState === STATE_GREETING) {
                targetTree = explodeTargets;
                targetRibbon = ribbonExplodeTargets;
                starTargetScale = 0;
            } else {
                if (isShowingMessage) {
                    targetTree = explodeTargets;
                    targetRibbon = ribbonExplodeTargets;
                    starTargetScale = 0; 
                } else {
                    targetTree = treeTargets;
                    targetRibbon = ribbonTargets;
                    starTargetScale = 1; 
                }
            }

            const speed = (currentState === STATE_TREE && !isShowingMessage) ? 0.04 : 0.02;

            const treePos = treeGeo.attributes.position.array;
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                treePos[i] += (targetTree[i] - treePos[i]) * speed;
            }
            treeGeo.attributes.position.needsUpdate = true;

            const ribbonPos = ribbonGeo.attributes.position.array;
            for (let i = 0; i < RIBBON_COUNT * 3; i++) {
                ribbonPos[i] += (targetRibbon[i] - ribbonPos[i]) * speed;
            }
            ribbonGeo.attributes.position.needsUpdate = true;

            let rotationStep = 0;
            if (currentState === STATE_INIT || currentState === STATE_GREETING) {
                rotationStep = -0.003; 
            } else {
                rotationStep = 0.002;
            }

            treeParticles.rotation.y += rotationStep;
            ribbonParticles.rotation.y += rotationStep;
            
            if (treeStarGroup) {
                treeStarGroup.rotation.y = treeParticles.rotation.y;
            }

            const time = Date.now();

            if (treeStarGroup) {
                treeStarGroup.scale.setScalar(
                    THREE.MathUtils.lerp(treeStarGroup.scale.x, starTargetScale, 0.05)
                );
            }

            bubbles.forEach((bubbleGroup) => {
                if (!bubbleGroup.visible) return; 
                const initPos = bubbleGroup.userData.initialPos;
                const offset = bubbleGroup.userData.offset;
                const s = bubbleGroup.userData.speed;
                bubbleGroup.position.x = initPos.x + Math.sin(time * s * 0.8 + offset.x) * 1.0;
                bubbleGroup.position.y = initPos.y + Math.sin(time * s * 1.0 + offset.y) * 1.5;
                bubbleGroup.position.z = initPos.z + Math.sin(time * s * 0.6 + offset.z) * 1.0;
                bubbleGroup.rotation.x += s;
                bubbleGroup.rotation.y += s;
            });

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>